use element::Language;
use vantle::Composition;

fn main() -> miette::Result<()> {
    let arguments = render::Arguments::parse();
    vantle::page(&arguments, "Molten", |c| {
        c.image("resource/logo.png", "Molten")
            .title("Molten")
            .subtitle("Computational expression over hypergraphs")
            .navigation(|n| {
                n.link("Info.html", "Info")
                    .link("Notice.html", "Notice")
                    .link("../Readme.html", "Vantle")
                    .link("../Module.html", "Module")
                    .link("../system/observation/Readme.html", "Observation")
                    .link("system/spatialize/Readme.html", "Spatialize")
                    .link("License.html", "License")
            })
            .rule()
            .paragraph(|p| {
                p.text("This document describes ")
                    .bold("all of the semantics")
                    .text(" of Molten\u{2019}s computational expression. Since Molten programs build ")
                    .bold("hypergraphs")
                    .text(", you are encouraged to embrace ")
                    .italic("polymorphism")
                    .text(" to keep your code efficient and reusable.")
            })
            .rule()
            .section("Theory", |s| {
                s.term("Concept", |t| {
                    t.text("an atom such as ")
                        .code("Human")
                        .text(", ")
                        .code("Earth")
                        .text(", ")
                        .code("Ready")
                        .text(". Stick to ")
                        .bold("one word per concept")
                        .text("; if you need multiple words, chain them with dots \u{2013} for example ")
                        .code("Earth.Location")
                        .text(" or ")
                        .code("Human.Man")
                        .text(". Avoid compound words. Invent new words. Ultimately, a concept is defined by its relationship to other concepts, the label is a comment for a consumer, such as yourself (help yourself understand your own graphs).")
                })
                .aside(|a| {
                    a.text("Avoid CamelCase (")
                        .code("LikeThis")
                        .text(") or underscores (")
                        .code("like_this")
                        .text("). Dots are the official way to express a path of related concepts.")
                })
                .aside(|a| {
                    a.text("Why? CamelCase and other multi-word mash-ups often hide multiple ideas inside a single label\u{2014}an indicator of weak or muddled abstraction. Molten encourages ")
                        .italic("one word \u{2192} one concept")
                        .text(". If you genuinely need two ideas, write them as ")
                        .code("First.Second")
                        .text(" so their relationship is explicit in the graph.")
                })
                .term("Orthogonality", |t| {
                    t.text("an independent dimension of evaluation holding its own set of concepts. Evaluation starts with one orthogonality; some constructs create additional ones that may later merge back together.")
                })
                .term("Relation", |t| {
                    t.text("a source to ")
                        .bold("any expression")
                        .text(" except a partition or ")
                        .code("void")
                        .text("; use this to express polymorphic edges inside the hypergraph.")
                })
            })
            .rule()
            .section("Syntax", |s| {
                s.table(|t| {
                    t.header(["Symbol", "Action", "Elaboration"])
                        .row([".", "\"with\"", "Group concepts together within the graph (no ordering)."])
                        .row([",", "\"meanwhile\"", "Split the current orthogonality into additional orthogonalities (new worlds)."])
                        .row(["[ \u{2026} ]", "\"from \u{2026} \"", "A source expression of how to walk the hypergraph."])
                        .row(["( \u{2026} )", "\"group \u{2026} \"", "Groups sub-expressions within a partition; used for precedence and clarity."])
                })
                .aside(|a| {
                    a.text("File extensions: a ")
                        .code(".lava")
                        .text(" file indicates a runnable Molten ")
                        .italic("script")
                        .text(", while a ")
                        .code(".magma")
                        .text(" file indicates a reusable Molten ")
                        .italic("library")
                        .text(". The semantics are identical; the distinction exists purely to help humans reason about intent.")
                })
                .subsection("Textual", |ss| {
                    ss.element("ul", |ul| {
                        ul.element("li", |li| {
                            li.span(|s| {
                                s.bold("Orderless")
                                    .text(" Molten does not march through the source left-to-right. Each orthogonality advances ")
                                    .italic("only")
                                    .text(" when the rule in front of it is enabled. Rules are ordered based upon ")
                                    .code(",")
                                    .text(" ")
                                    .code("()")
                                    .text(", and ")
                                    .code("[]")
                                    .text(" semantics.")
                            })
                        })
                        .element("li", |li| {
                            li.span(|s| {
                                s.text("A ")
                                    .bold("dot")
                                    .text(" ")
                                    .code(".")
                                    .text(" simply groups concepts ")
                                    .italic("with")
                                    .text(" one another inside the same orthogonality.")
                            })
                        })
                        .element("li", |li| {
                            li.span(|s| {
                                s.text("A ")
                                    .bold("comma")
                                    .text(" ")
                                    .code(",")
                                    .text(" clones the current orthogonality ")
                                    .bold("once for every extra branch")
                                    .text(", so you can have any number of orthogonalities running in parallel. They move forward independently until another rule brings them back together.")
                            })
                        })
                        .element("li", |li| {
                            li.span(|s| {
                                s.text("A ")
                                    .bold("bracket")
                                    .text(" ")
                                    .code("[\u{2026}]")
                                    .text(" blocks its arriving orthogonality(ies) until they already hold every listed concept. Once satisfied it removes those concepts, inserts the ones that follow the bracket, and lets the orthogonality(ies) proceed.")
                            })
                        })
                        .element("li", |li| {
                            li.span(|s| {
                                s.text("A ")
                                    .bold("parentheses")
                                    .text(" ")
                                    .code("()")
                                    .text(" groups items within a partition; they have no effect on state by themselves.")
                            })
                        })
                    })
                })
            })
            .rule()
            .section("Compositions", |s| {
                s.paragraph(|p| p.text("Compositions emerge from combining syntactic primitives."))
                    .subsection("Join", |ss| {
                        ss.paragraph(|p| {
                            p.text("Any number of orthogonalities \u{2013} each carrying one of the required concepts (")
                                .code("A")
                                .text(", ")
                                .code("B")
                                .text(", etc.) \u{2013} must all reach the bracket. When they do, they ")
                                .bold("fuse")
                                .text(" into a single orthogonality; the listed concepts disappear and ")
                                .code("C")
                                .text(" is added. Execution then proceeds in that unified orthogonality.")
                        })
                    })
                    .subsection("Scope", |ss| {
                        ss.paragraph(|p| {
                            p.text("An orthogonality holding ")
                                .code("A")
                                .text(" replaces it with the grouped expression ")
                                .code("([B.C] D)")
                                .text(". Inside that scope, ")
                                .code("B.C")
                                .text(" is required; once present, it is swapped for ")
                                .code("D")
                                .text(". The scope then collapses, leaving ")
                                .code("D")
                                .text(" in the orthogonality\u{2019}s state.")
                        })
                    })
                    .subsection("Polymorphism", |ss| {
                        ss.paragraph(|p| {
                            p.text("Two orthogonalities, ")
                                .code("A")
                                .text(" and ")
                                .code("B")
                                .text(" derive ")
                                .code("C")
                                .text(". This means that ")
                                .code("A.D")
                                .text(" and ")
                                .code("B.D")
                                .text(" both match ")
                                .code("[C.D]")
                                .text(" such that the resulting transformation yields ")
                                .code("A.E")
                                .text(" or ")
                                .code("B.E")
                                .text(".")
                        })
                        .element("ul", |ul| {
                            ul.element("li", |li| {
                                li.span(|s| {
                                    s.code("C")
                                        .text(" is considered a ")
                                        .code("derivation")
                                        .text(" of ")
                                        .code("A")
                                        .text(" and ")
                                        .code("B")
                                        .text(", but not ")
                                        .code("A")
                                        .text(" and ")
                                        .code("B")
                                        .text(" themselves. As a result, the originating ")
                                        .code("atoms")
                                        .text(" are preserved in the transformation.")
                                })
                            })
                            .element("li", |li| {
                                li.span(|s| {
                                    s.text("If ")
                                        .code("C")
                                        .text(" were instead provided, ")
                                        .code("C.D")
                                        .text(", it would be considered a ")
                                        .code("measure")
                                        .text(" of ")
                                        .code("C")
                                        .text(", as such it is ")
                                        .italic("consumed")
                                        .text(" yielding just ")
                                        .code("E")
                                        .text(".")
                                })
                            })
                        })
                        .heading(4, "Recursive derivations")
                        .paragraph(|p| {
                            p.code("A")
                                .text(" reproduces itself inductively; after sufficient iterations, ")
                                .code("A.A.A.A.A")
                                .text(" matches ")
                                .code("[A.A.A.A.A] D")
                                .text(" and transforms to ")
                                .code("D")
                                .text(".")
                        })
                        .heading(4, "Curry\u{2019}s Paradox")
                        .paragraph(|p| {
                            p.text("Curry\u{2019}s Paradox often occurs within logical systems, where some logical deduction existing invalidates its own existence via self-referential logic. Molten does not care about this; it will evaluate. It is the programmer\u{2019}s responsibility to understand the semantics of their program, and such behaviors will appear as that node being isomorphic to itself. This may be behavior you want, and eliminating it requires a nondeterministic \u{201c}step\u{201d} runtime, so no such feature exists. It can be useful to investigate the logical consistency of your rules.")
                        })
                        .heading(5, "Philosophical note")
                        .paragraph(|p| {
                            p.text("This is essentially the problem of axioms. It is a feature of reality, not a bug.")
                        })
                    })
            })
            .rule()
            .section("Examples", |s| {
                s.element("pre", |p| {
                    p.element("code", |c| {
                        c.class("language-molten").text(
                            "Human.Male, \nEarth.Location.America,\n[Human.Male, Earth.Location.America] American.Citizen.Male",
                        )
                    })
                })
                .paragraph(|p| {
                    p.text("Note that this function is an ")
                        .italic("infinite generator")
                        .text(" of the ")
                        .code("American.Citizen.Male")
                        .text(" graph. First, it generates ")
                        .code("Human.Male, Earth.Location.America")
                        .text(", which then joins to ")
                        .code("American.Citizen.Male")
                        .text(". At any given state (with breadth-first evaluation), there is one or zero copies of ")
                        .code("Human.Male, Earth.Location.America")
                        .text(" and an ever increasing copy of ")
                        .code("American.Citizen.Male")
                        .text(".")
                })
                .subsection("Boolean Logic", |ss| {
                    ss.code("boolean.magma", Language::Molten)
                })
                .subsection("Joins", |ss| ss.code("join.magma", Language::Molten))
            })
            .rule()
            .section("Forge", |s| {
                s.paragraph(|p| {
                    p.text("Forge ")
                        .code("1.0.0")
                        .text(" supports temporal runtime for Molten.")
                })
                .subsection("Invoke", |ss| {
                    ss.paragraph(|p| p.text("Run the forge lava interactive runtime:"))
                        .shell("bazel run //Molten/system/forge:command lava")
                        .paragraph(|p| {
                            p.text("This starts an interactive session where you can enter Molten expressions line by line. Each expression is evaluated and the resulting hypergraph state is displayed. Subsequent commands are ")
                                .italic("disjoint")
                                .text(" worlds to the previous graphs, but still evolve any existing state.")
                        })
                })
                .subsection("Observation", |ss| {
                    ss.paragraph(|p| p.text("Stream execution traces to a file:"))
                        .shell("bazel run //Molten/system/forge:command lava -- --address file:///tmp/trace.jsonl")
                        .paragraph(|p| p.text("Or to a running peer (others may source or sink from or to your evaluation):"))
                        .shell("bazel run //Molten/system/forge:command lava -- --address grpc://127.0.0.1:50051")
                        .paragraph(|p| {
                            p.text("Functions decorated with ")
                                .code("#[trace(channels = [core])]")
                                .text(" emit spans to the configured sink.")
                        })
                })
            })
    })
}
