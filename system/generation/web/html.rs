use std::collections::{HashMap, HashSet};
use std::fmt::Write;

use clap::Parser;
use element::{Element, Language, Source};
use observe::trace;
use page::Page;
use span::Fragment;
use style::{Keyframe, Media, Properties, Style};

#[derive(Parser)]
#[command(
    name = "document",
    about = "Generate a document from a Rust DSL page definition"
)]
pub struct Arguments {
    #[arg(long)]
    pub output: std::path::PathBuf,

    #[arg(long)]
    pub destination: String,

    #[arg(long)]
    pub data: Vec<String>,
}

impl Arguments {
    #[must_use]
    pub fn parse() -> Self {
        <Self as clap::Parser>::parse()
    }

    #[must_use]
    pub fn root(&self) -> String {
        let depth = self.destination.chars().filter(|&c| c == '/').count();
        if depth == 0 {
            "./".into()
        } else {
            "../".repeat(depth)
        }
    }
}

#[trace(channels = [document])]
pub fn render<S: std::hash::BuildHasher>(
    page: &Page,
    data: &HashMap<String, String, S>,
) -> miette::Result<String> {
    let mut renderer = Renderer {
        html: String::new(),
        data,
        headings: Vec::new(),
        identifiers: HashSet::new(),
    };

    renderer
        .html
        .push_str("<!DOCTYPE html>\n<!-- Generated by Vantle::Web -->\n<html lang=\"en\"");
    if let Some(ref context) = page.context {
        write!(renderer.html, " data-context=\"{}\"", escape(context)).unwrap();
    }
    if let Some(ref identifier) = page.identifier {
        write!(renderer.html, " data-page=\"{}\"", escape(identifier)).unwrap();
    }
    if let Some(ref root) = page.root {
        write!(renderer.html, " data-root=\"{}\"", escape(root)).unwrap();
    }
    renderer.html.push_str(">\n<head>\n");
    renderer.html.push_str("<meta charset=\"UTF-8\">\n");
    renderer
        .html
        .push_str("<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n");
    writeln!(renderer.html, "<title>{}</title>", escape(&page.title)).unwrap();

    if let Some(ref path) = page.favicon {
        writeln!(
            renderer.html,
            "<link rel=\"icon\" type=\"image/x-icon\" href=\"{}\">",
            escape(path)
        )
        .unwrap();
    }

    renderer.html.push_str("<script>try{let d=document.documentElement;let t=localStorage.getItem('theme');if(t)d.setAttribute('data-theme',t)}catch(e){}</script>\n");

    if let Some(ref path) = page.stylesheet {
        writeln!(
            renderer.html,
            "<link rel=\"stylesheet\" href=\"{}\">",
            escape(path)
        )
        .unwrap();
    }

    if let Some(ref wasm) = page.wasm {
        write!(
            renderer.html,
            "<script type=\"module\">\nimport init from '{}';\nawait init();\n</script>\n",
            escape(wasm)
        )
        .unwrap();
    }

    renderer.html.push_str("</head>\n<body>\n");

    for element in &page.body {
        renderer.element(element, 0)?;
    }

    if !renderer.headings.is_empty() {
        let placeholder = "<aside class=\"outline\" aria-label=\"Table of contents\"></aside>";
        if let Some(position) = renderer.html.find(placeholder) {
            let current_indent = renderer.html[..position]
                .rfind('\n')
                .map_or(0, |newline| position - newline - 1);
            let pad = " ".repeat(current_indent);
            let inner = " ".repeat(current_indent + 2);

            let minimum = renderer
                .headings
                .iter()
                .map(|(d, _, _)| *d)
                .min()
                .unwrap_or(1);

            let mut outline =
                "<aside class=\"outline\" aria-label=\"Table of contents\">\n".to_string();
            for (depth, id, text) in &renderer.headings {
                let level = depth - minimum;
                writeln!(
                    outline,
                    "{inner}<a href=\"#{id}\" data-depth=\"{level}\">{}</a>",
                    escape(text)
                )
                .unwrap();
            }
            write!(outline, "{pad}</aside>").unwrap();

            renderer
                .html
                .replace_range(position..position + placeholder.len(), &outline);
        }
    }

    renderer.html.push_str("</body>\n</html>\n");

    Ok(renderer.html)
}

#[trace(channels = [document])]
#[must_use]
pub fn css(style: &Style) -> String {
    let mut output = String::from("/* Generated by Vantle::Web */\n\n");
    render_style(&mut output, style);
    output
}

#[trace(channels = [document])]
pub fn generate(arguments: &Arguments, page: Page) -> miette::Result<()> {
    let data = load(&arguments.data)?;
    let html = render(&page, &data)?;
    emit(&arguments.output, &html)
}

#[trace(channels = [document])]
pub fn stylesheet(arguments: &Arguments, style: &Style) -> miette::Result<()> {
    emit(&arguments.output, &css(style))
}

#[trace(channels = [document])]
fn emit(path: &std::path::Path, content: &str) -> miette::Result<()> {
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent).map_err(|_| error::Error::Output {
            path: parent.display().to_string(),
        })?;
    }

    std::fs::write(path, content).map_err(|_| error::Error::Output {
        path: path.display().to_string(),
    })?;

    Ok(())
}

#[trace(channels = [document])]
fn load(paths: &[String]) -> miette::Result<HashMap<String, String>> {
    let mut data = HashMap::new();
    for path in paths {
        let content = std::fs::read_to_string(path).map_err(|_| {
            let available = data.keys().cloned().collect::<Vec<_>>();
            error::Error::source(path, &available)
        })?;
        let name = std::path::Path::new(path)
            .file_name()
            .unwrap_or_default()
            .to_string_lossy()
            .into_owned();
        data.insert(name, content);
    }
    Ok(data)
}

#[trace(channels = [document])]
fn render_style(html: &mut String, style: &Style) {
    if !style.variables.is_empty() {
        html.push_str(":root {\n");
        for (name, value) in &style.variables {
            writeln!(html, "  {name}: {value};").unwrap();
        }
        html.push_str("}\n");
    }

    for rule in &style.rules {
        html.push('\n');
        writeln!(html, "{} {{", rule.selector).unwrap();
        render_properties(html, &rule.properties);
        html.push_str("}\n");
    }

    for keyframe in &style.keyframes {
        html.push('\n');
        render_keyframe(html, keyframe);
    }

    for media in &style.media {
        html.push('\n');
        render_media(html, media);
    }
}

#[trace(channels = [document])]
fn render_properties(html: &mut String, properties: &Properties) {
    for (name, value) in &properties.entries {
        writeln!(html, "  {name}: {value};").unwrap();
    }
}

#[trace(channels = [document])]
fn render_keyframe(html: &mut String, keyframe: &Keyframe) {
    writeln!(html, "@keyframes {} {{", keyframe.name).unwrap();
    for step in &keyframe.steps {
        writeln!(html, "  {} {{", step.selector).unwrap();
        for (name, value) in &step.properties.entries {
            writeln!(html, "    {name}: {value};").unwrap();
        }
        html.push_str("  }\n");
    }
    html.push_str("}\n");
}

#[trace(channels = [document])]
fn render_media(html: &mut String, media: &Media) {
    writeln!(html, "@media ({}) {{", media.query).unwrap();

    if !media.style.variables.is_empty() {
        html.push_str("  :root {\n");
        for (name, value) in &media.style.variables {
            writeln!(html, "    {name}: {value};").unwrap();
        }
        html.push_str("  }\n");
    }

    for rule in &media.style.rules {
        writeln!(html, "  {} {{", rule.selector).unwrap();
        for (name, value) in &rule.properties.entries {
            writeln!(html, "    {name}: {value};").unwrap();
        }
        html.push_str("  }\n");
    }

    html.push_str("}\n");
}

struct Renderer<'a, S: std::hash::BuildHasher> {
    html: String,
    data: &'a HashMap<String, String, S>,
    headings: Vec<(u8, String, String)>,
    identifiers: HashSet<String>,
}

impl<S: std::hash::BuildHasher> Renderer<'_, S> {
    #[trace(channels = [document])]
    fn element(&mut self, element: &Element, depth: usize) -> miette::Result<()> {
        match element {
            Element::Tag {
                name,
                attributes,
                children,
            } => self.tag(name, attributes, children, depth)?,
            Element::Text(text) => self.html.push_str(&escape(text)),
            Element::Span(fragments) => render_fragments(&mut self.html, fragments),
            Element::Raw(raw) => self.html.push_str(raw),
            Element::Code { source, language } => {
                indent(&mut self.html, depth);
                self.code(source, *language)?;
                self.html.push('\n');
            }
            Element::Inject { name } => {
                render_inject(&mut self.html, name, self.data)?;
            }
            Element::Markdown { name } => {
                self.markdown(name)?;
            }
        }
        Ok(())
    }

    fn inline(&mut self, element: &Element) -> miette::Result<()> {
        match element {
            Element::Tag {
                name,
                attributes,
                children,
            } => {
                self.open(name, attributes, &[]);
                self.html.push('>');
                match name.as_str() {
                    "img" | "br" | "hr" | "input" | "meta" | "link" => {}
                    _ => {
                        for child in children {
                            self.inline(child)?;
                        }
                        write!(self.html, "</{name}>").unwrap();
                    }
                }
            }
            Element::Text(text) => self.html.push_str(&escape(text)),
            Element::Span(fragments) => render_fragments(&mut self.html, fragments),
            Element::Raw(raw) => self.html.push_str(raw),
            Element::Code { source, language } => self.code(source, *language)?,
            Element::Inject { name } => render_inject(&mut self.html, name, self.data)?,
            Element::Markdown { name } => self.markdown(name)?,
        }
        Ok(())
    }

    fn open(&mut self, name: &str, attributes: &[(String, String)], children: &[Element]) {
        self.html.push('<');
        self.html.push_str(name);
        for (key, value) in attributes {
            write!(self.html, " {key}=\"{}\"", escape(value)).unwrap();
        }

        let heading = match name {
            "h1" => Some(1u8),
            "h2" => Some(2),
            "h3" => Some(3),
            "h4" => Some(4),
            "h5" => Some(5),
            "h6" => Some(6),
            _ => None,
        };

        if let Some(heading) = heading {
            let text = extract_text(children);
            if !text.is_empty() {
                let existing = attributes.iter().find(|(k, _)| k == "id");
                let id = if let Some((_, value)) = existing {
                    value.clone()
                } else {
                    let id = deduplicate(slugify(&text), &self.identifiers);
                    write!(self.html, " id=\"{}\"", escape(&id)).unwrap();
                    id
                };
                self.identifiers.insert(id.clone());
                self.headings.push((heading, id, text));
            }
        }
    }

    #[trace(channels = [document])]
    fn tag(
        &mut self,
        name: &str,
        attributes: &[(String, String)],
        children: &[Element],
        depth: usize,
    ) -> miette::Result<()> {
        indent(&mut self.html, depth);
        self.open(name, attributes, children);
        self.html.push('>');

        match name {
            "img" | "br" | "hr" | "input" | "meta" | "link" => {
                self.html.push('\n');
            }
            _ => {
                let nested = children
                    .iter()
                    .any(|c| matches!(c, Element::Tag { .. } | Element::Code { .. }));
                if nested && name != "pre" {
                    self.html.push('\n');
                    for child in children {
                        self.element(child, depth + 1)?;
                    }
                    indent(&mut self.html, depth);
                } else {
                    for child in children {
                        self.inline(child)?;
                    }
                }
                writeln!(self.html, "</{name}>").unwrap();
            }
        }

        Ok(())
    }

    #[trace(channels = [document])]
    fn code(&mut self, source: &Source, language: Language) -> miette::Result<()> {
        let text = match source {
            Source::File(name) => self.data.get(name.as_str()).ok_or_else(|| {
                let available = self.data.keys().cloned().collect::<Vec<_>>();
                error::Error::source(name, &available)
            })?,
            Source::Inline(text) => text,
        };

        let highlighted = highlight::highlight(text, language)?;
        write!(
            self.html,
            "<div class=\"code-block\" data-language=\"{}\">{}</div>",
            language.name(),
            highlighted
        )
        .unwrap();

        Ok(())
    }

    #[trace(channels = [document])]
    fn markdown(&mut self, name: &str) -> miette::Result<()> {
        let source = self.data.get(name).ok_or_else(|| {
            let available = self.data.keys().cloned().collect::<Vec<_>>();
            error::Error::source(name, &available)
        })?;

        let mut heading: Option<(u8, String)> = None;

        for event in pulldown_cmark::Parser::new(source) {
            match event {
                pulldown_cmark::Event::Start(pulldown_cmark::Tag::Heading { level, .. }) => {
                    let depth = level as u8;
                    heading = Some((depth, String::new()));
                }
                pulldown_cmark::Event::End(pulldown_cmark::TagEnd::Heading(_)) => {
                    if let Some((depth, text)) = heading.take() {
                        let id = deduplicate(slugify(&text), &self.identifiers);
                        self.identifiers.insert(id.clone());
                        self.headings.push((depth, id.clone(), text.clone()));
                        writeln!(
                            self.html,
                            "<h{depth} id=\"{id}\">{}</h{depth}>",
                            escape(&text)
                        )
                        .unwrap();
                    }
                }
                pulldown_cmark::Event::Text(text) => {
                    if let Some((_, ref mut heading_text)) = heading {
                        heading_text.push_str(&text);
                    } else {
                        self.html.push_str(&escape(&text));
                    }
                }
                pulldown_cmark::Event::Code(code) => {
                    if let Some((_, ref mut heading_text)) = heading {
                        heading_text.push_str(&code);
                    } else {
                        write!(self.html, "<code>{}</code>", escape(&code)).unwrap();
                    }
                }
                _ => {
                    if heading.is_none() {
                        pulldown_cmark::html::push_html(&mut self.html, std::iter::once(event));
                    }
                }
            }
        }

        Ok(())
    }
}

fn indent(html: &mut String, depth: usize) {
    for _ in 0..depth {
        html.push_str("  ");
    }
}

#[trace(channels = [document])]
fn render_fragments(html: &mut String, fragments: &[Fragment]) {
    for fragment in fragments {
        match fragment {
            Fragment::Text(text) => html.push_str(&escape(text)),
            Fragment::Bold(text) => write!(html, "<strong>{}</strong>", escape(text)).unwrap(),
            Fragment::Italic(text) => write!(html, "<em>{}</em>", escape(text)).unwrap(),
            Fragment::Code(text) => write!(html, "<code>{}</code>", escape(text)).unwrap(),
            Fragment::Link { href, text } => {
                write!(html, "<a href=\"{}\">{}</a>", escape(href), escape(text)).unwrap();
            }
        }
    }
}

#[trace(channels = [document])]
fn render_inject<S: std::hash::BuildHasher>(
    html: &mut String,
    name: &str,
    data: &HashMap<String, String, S>,
) -> miette::Result<()> {
    let source = data.get(name).ok_or_else(|| {
        let available = data.keys().cloned().collect::<Vec<_>>();
        error::Error::source(name, &available)
    })?;

    html.push_str(source);

    Ok(())
}

fn extract_text(elements: &[Element]) -> String {
    let mut text = String::new();
    for element in elements {
        match element {
            Element::Text(t) => text.push_str(t),
            Element::Span(fragments) => {
                for fragment in fragments {
                    match fragment {
                        Fragment::Text(t)
                        | Fragment::Bold(t)
                        | Fragment::Italic(t)
                        | Fragment::Code(t)
                        | Fragment::Link { text: t, .. } => text.push_str(t),
                    }
                }
            }
            Element::Tag { children, .. } => text.push_str(&extract_text(children)),
            _ => {}
        }
    }
    text
}

fn slugify(text: &str) -> String {
    let mut output = String::with_capacity(text.len());
    for c in text.chars() {
        if c.is_alphanumeric() {
            for lower in c.to_lowercase() {
                output.push(lower);
            }
        } else {
            output.push('-');
        }
    }
    output
}

fn deduplicate(base: String, identifiers: &HashSet<String>) -> String {
    if !identifiers.contains(&base) {
        return base;
    }
    let mut suffix = 2;
    loop {
        let candidate = format!("{base}-{suffix}");
        if !identifiers.contains(&candidate) {
            return candidate;
        }
        suffix += 1;
    }
}

fn escape(text: &str) -> String {
    escape::escape(text)
}
